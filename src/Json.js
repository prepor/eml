// Generated by BUCKLESCRIPT VERSION 1.2.1 , PLEASE EDIT WITH CARE
'use strict';

var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions");
var Block           = require("bs-platform/lib/js/block");
var Js_json         = require("bs-platform/lib/js/js_json");
var Curry           = require("bs-platform/lib/js/curry");
var Printf          = require("bs-platform/lib/js/printf");
var $$Array         = require("bs-platform/lib/js/array");
var $$String        = require("bs-platform/lib/js/string");
var Result          = require("./result");

function type_of(x) {
  if (typeof x === "string") {
    return "string";
  }
  else if (typeof x === "number") {
    return "number";
  }
  else if (typeof x === "boolean") {
    return "boolean";
  }
  else if (x === null) {
    return "null";
  }
  else if (Array.isArray(x)) {
    return "array";
  }
  else {
    return "object";
  }
}

var $$Error = Caml_exceptions.create("Json.Decoder.Error");

function type_error(expected, x) {
  var e_000 = Curry._2(Printf.sprintf(/* Format */[
            /* String_literal */Block.__(11, [
                "Expected ",
                /* String */Block.__(2, [
                    /* No_padding */0,
                    /* String_literal */Block.__(11, [
                        ", got ",
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* End_of_format */0
                          ])
                      ])
                  ])
              ]),
            "Expected %s, got %s"
          ]), expected, type_of(x));
  var e = /* tuple */[
    e_000,
    /* [] */0
  ];
  throw [
        $$Error,
        e
      ];
}

function string(x) {
  var match = Js_json.reify_type(x);
  if (match[0] !== 0) {
    return type_error("string", x);
  }
  else {
    return match[1];
  }
}

function $$int(x) {
  var match = Js_json.reify_type(x);
  if (match[0] !== 1) {
    return type_error("number", x);
  }
  else {
    return match[1] | 0;
  }
}

function $$float(x) {
  var match = Js_json.reify_type(x);
  if (match[0] !== 1) {
    return type_error("number", x);
  }
  else {
    return match[1];
  }
}

function bool(x) {
  var match = Js_json.reify_type(x);
  if (match[0] !== 4) {
    return type_error("boolean", x);
  }
  else {
    return +match[1];
  }
}

function $$null$1(v, x) {
  var match = Js_json.reify_type(x);
  if (match[0] >= 5) {
    return v;
  }
  else {
    return type_error("null", x);
  }
}

function list(d, x) {
  var match = Js_json.reify_type(x);
  if (match[0] !== 3) {
    return type_error("array", x);
  }
  else {
    return $$Array.to_list($$Array.map(d, match[1]));
  }
}

function array(d, x) {
  var match = Js_json.reify_type(x);
  if (match[0] !== 3) {
    return type_error("array", x);
  }
  else {
    return $$Array.map(d, match[1]);
  }
}

function array_size_error(expected, v) {
  var e_000 = Curry._2(Printf.sprintf(/* Format */[
            /* String_literal */Block.__(11, [
                "Expected array[of size ",
                /* Int */Block.__(4, [
                    /* Int_i */3,
                    /* No_padding */0,
                    /* No_precision */0,
                    /* String_literal */Block.__(11, [
                        "], got array[of size ",
                        /* Int */Block.__(4, [
                            /* Int_i */3,
                            /* No_padding */0,
                            /* No_precision */0,
                            /* Char_literal */Block.__(12, [
                                /* "]" */93,
                                /* End_of_format */0
                              ])
                          ])
                      ])
                  ])
              ]),
            "Expected array[of size %i], got array[of size %i]"
          ]), expected, v.length);
  var e = /* tuple */[
    e_000,
    /* [] */0
  ];
  throw [
        $$Error,
        e
      ];
}

function tuple1(d, x) {
  var match = Js_json.reify_type(x);
  if (match[0] !== 3) {
    return type_error("array", x);
  }
  else {
    var v = match[1];
    if (v.length !== 1) {
      return array_size_error(1, v);
    }
    else {
      return Curry._1(d, v[0]);
    }
  }
}

function tuple2(da, db, x) {
  var match = Js_json.reify_type(x);
  if (match[0] !== 3) {
    return type_error("array", x);
  }
  else {
    var v = match[1];
    if (v.length !== 2) {
      return array_size_error(2, v);
    }
    else {
      var a = v[0];
      var b = v[1];
      return /* tuple */[
              Curry._1(da, a),
              Curry._1(db, b)
            ];
    }
  }
}

function $unknown$eq(field, d, x) {
  var match = x[field];
  if (match !== undefined) {
    try {
      return Curry._1(d, match);
    }
    catch (exn){
      if (exn[0] === $$Error) {
        var match$1 = exn[1];
        throw [
              $$Error,
              /* tuple */[
                match$1[0],
                /* :: */[
                  field,
                  match$1[1]
                ]
              ]
            ];
      }
      else {
        throw exn;
      }
    }
  }
  else {
    var e_000 = Curry._1(Printf.sprintf(/* Format */[
              /* String_literal */Block.__(11, [
                  "No field ",
                  /* String */Block.__(2, [
                      /* No_padding */0,
                      /* End_of_format */0
                    ])
                ]),
              "No field %s"
            ]), field);
    var e = /* tuple */[
      e_000,
      /* [] */0
    ];
    throw [
          $$Error,
          e
        ];
  }
}

function succeed(v, _) {
  return v;
}

function object1(d, x) {
  var match = Js_json.reify_type(x);
  if (match[0] !== 2) {
    return type_error("object", x);
  }
  else {
    return Curry._1(d, match[1]);
  }
}

function object2(f, da, db, x) {
  var match = Js_json.reify_type(x);
  if (match[0] !== 2) {
    return type_error("object", x);
  }
  else {
    var v = match[1];
    return Curry._2(f, Curry._1(da, v), Curry._1(db, v));
  }
}

function at(path, d, x) {
  if (path) {
    var path$1 = path[1];
    var p = path[0];
    var f = function (param) {
      return $unknown$eq(p, function (param) {
                  return at(path$1, d, param);
                }, param);
    };
    return object1(f, x);
  }
  else {
    return Curry._1(d, x);
  }
}

function map(f, d, x) {
  return Curry._1(f, Curry._1(d, x));
}

function required(field, val_dec, dec, x) {
  var a = function (param) {
    return $unknown$eq(field, val_dec, param);
  };
  var b = dec;
  var x$1 = x;
  var match = Js_json.reify_type(x$1);
  if (match[0] !== 2) {
    return type_error("object", x$1);
  }
  else {
    return Curry._2(b, x$1, Curry._1(a, match[1]));
  }
}

function decode_value(d, v) {
  try {
    return Result.ok(Curry._1(d, v));
  }
  catch (exn){
    if (exn[0] === $$Error) {
      var match = exn[1];
      var path = match[1];
      var s = match[0];
      return Result.err(path ? Curry._2(Printf.sprintf(/* Format */[
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String_literal */Block.__(11, [
                                    " at ",
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* End_of_format */0
                                      ])
                                  ])
                              ]),
                            "%s at %s"
                          ]), s, $$String.concat(" / ", path)) : s);
    }
    else {
      throw exn;
    }
  }
}

function decode_string(d, s) {
  try {
    return decode_value(d, JSON.parse(s));
  }
  catch (exn){
    return Result.err("JSON parsing error");
  }
}

var Decoder = [
  string,
  $$int,
  $$float,
  bool,
  $$null$1,
  list,
  array,
  tuple1,
  tuple2,
  $unknown$eq,
  succeed,
  object1,
  object2,
  at,
  map,
  succeed,
  required,
  decode_string,
  decode_value
];

exports.type_of = type_of;
exports.Decoder = Decoder;
/* No side effect */
